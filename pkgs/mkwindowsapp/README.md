# mkWindowsApp

`mkWindowsApp` is a Nix function which installs Wine-compatible Windows applications on [NixOS](https://nixos.org). `mkWindowsApp` retains some of the benefits provided by NixOS in the way Windows applications are installed. Namely:

 - Multiple versions of a Windows application can be installed simultaneously; Although only one can be active in the environment, of course.
 - Windows applications can be _rolled back_ along with other native Linux applications installed with Nix.
 - Installations are reproducible; Though (purposely) not to the same extent as native applications.

## How does it work?

`mkWindowsApp` dynamically creates $WINEPREFIX-es (aka. Wine Bottles) at runtime using an overlay filesystem. The overlay filesystem consists of three filesystem layers (listed from lowest to highest):

 1. The _Windows_ layer: This layer consists of an initialized Wine Bottle. It can be used by multiple Windows applications, but no applications (other than the defaults installed by Wine) are installed in this layer. During runtime this layer is mounted read-only.
 2. The _App_ layer: This layer consists of the installed Windows application. During runtime this layer is mounted read-only.
 3. The _Read/Write_ layer: This layer can be written to and serves as the upper layer of the overlay. This layer is created at runtime and is discarded when the Windows application terminates.

These layers are stored not in the Nix store, but rather in `$HOME/.cache/mkWindows`. Hence, what actually happens is `mkWindows` creates a script[^1] which when executed installs and then runs a Windows application. The said script will create the necessary layers and then use them to create a Wine Bottle for the application to run in. Once the application terminates, the entire Wine Bottle is discarded, but the layers are left intact.

## FAQ

 1. Since Wine Bottles are temporary, what happens to files created when a Windows application is running? _Any files not saved outside of the Wine Bottle are discarded as well. Therefore, package maintainers must account for where important files are stored, such as configuration files, to ensure they are stored outside of the Wine Bottle; Symbolic links can be used for this. In addition, users must ensure to use the Z:\ drive when saving important information._
 2. Do the layers need to be garbage-collected? _Yes, the package `mkwindowsapp-tools` has a garbage collector which should be run after `nix-collect-garbage`._
 3. How does the garbage collector know what can be deleted? _`mkWindowsApp` uses the layers to implement something similar to the Nix store. Each layer has a input hash, which similar to Nix, encapsulates the dependencies of the layer. The Windows layer input is purposely made to be imprecise; It uses the Wine version and architecture as the inputs. This is to avoid recreating such a large layer when irrelevant things change. The app layer input hash is simply the script generated by `mkWindowsApp`, which encapsulates all of the inputs related to the application being installed. Thus the garbage collector checks each layer to see if the script which generated it still exists in the Nix store. If it does not, then it deletes the layer._
 4. How do you install a Windows application that uses `mkWindowsApp`? _The same way any other Nix package is installed. But note that installing the Nix package doesn't actually install the Windows application. The Windows application is installed when you run the script which is installed by the Nix package. When a Windows application is installed non-interactively, it gives the illusion of having installed the application before-hand. However, there's a noticeable lag in startup time when layers need to be created._
 5. As an end-user, how will this work in practice? _Let's use Notepad++ as an example:_ 
   1. First you need to have a NixOS system built as a Nix Flake, since this repo is a Nix Flake. 
   2. Next, you add the Nix Flake `github:emmanuelrosa/erosanix` as an input; I recommend setting it up to follow your Nixpkgs input. 
   3. Then, you add the package `erosanix.packages."${system}".notepad-plus-plus` to your `environment.systemPackages`. 
   4. Next, run `nixos-rebuilt switch`.
   5. Use your favorite app launcher UI (or the command line) to run `notepad++`. Alternatively, you can use `xdg-open` or a file manager to open a text file.
   6. If a _Windows layer_ needs to be created, you'll see a notification from Wine. Then, Notepad++ will be installed and launched.
5. How can I package a Windows application with `mkWindowsApp`? _See the following section for an example package._

## An example package

Here's an annotated example of a package which uses `mkWindowsApp` to install a fictitious application named `foobarbaz`:

```
{ stdenv
, lib
, mkWindowsApp
, wine # Must be compatible with wineArch For win64 I use pkgs.wineWowPackages.full
, wineArch # Can be "win32" or "win64"
, fetchurl
}:
mkWindowsApp rec { # Use mkWindowsApp just like mkDerivation.
  pname = "foobarbaz";
  version = "1.2.3";
  
  src = fetchurl {
    url = "https://foobarbaz.io/download/foobarbaz-${version}.exe";
    shasum256 = "something-goes-here";
  };

  dontUnpack = true;
  wineArch = "win64";

  # This is executed to install the Windows application.
  # mkWindowsApp will set up a Wine Bottle and then run this script. Anything written to the Wine Bottle
  # will be stored in the application layer.
  # wine, winetricks, cabextract, $WINEPREFIX, $WINEARCH, and $WINEDLLOVERRIDES are available and set up.
  winAppInstall = ''
    winetricks corefonts
    wineserver -w
    
    wine start /unix ${src} /S
    wineserver -w
    
    rm -f "$WINEPREFIX/drive_c/delete-this-file"
  '';

  # This is executed after winAppInstall (if needed)  to run the Windows application.
  # mkWindowsApp will set up a Wine Bottle and then run this script. 
  # By this time both read-only layers would have been created, so anything written to the Wine Bottle
  # will be discarded once the script terminates.
  # wine, winetricks, cabextract, $WINEPREFIX, $WINEARCH, and $WINEDLLOVERRIDES are available and set up.
  winAppRun = ''
   # The following filesystem changes will happen in the read-write later, and will not be persisted.
   rm -fR "$WINEPREFIX/drive_c/users/$USER/Application Data/foobarbaz"
   
   # This is an example of setting up data to be persisted in the user's home directory.
   mkdir -p "$HOME/.config/foobarbaz"
   ln -s -v "$HOME/.config/foobarbaz" "$WINEPREFIX/drive_c/users/$USER/Application Data/"

   wine start /unix "$WINEPREFIX/drive_c/Program Files/foobarbaz/foobarbaz.exe" "$ARGS"
  '';

  installPhase = ''
    runHook preInstall

    # .launcher is the script created by mkWindowsApp. DO NOT RENAME OR DELETE THIS FILE!
    # It's used in the input hash for the app layer, so that the garbage collector knows
    # not to delete the layer.
    # Instead, link to it.
    ln -s $out/bin/.launcher $out/bin/foobarbaz
    
    runHook postInstall
  '';

  meta = with lib; {
    description = "An example of packaging a Windows application with mkWindowsApp.";
    homepage = "https://foobarbaz.io";
    license = licenses.gpl3Plus;
    maintainers = with maintainers; [ emmanuelrosa ];
    platforms = [ "x86_64-linux" "i386-linux" ];
  };
}
```

[^1]: The script is based on [wrapWine](https://github.com/lucasew/nixcfg/blob/fd523e15ccd7ec2fd86a3c9bc4611b78f4e51608/packages/wrapWine.nix).
